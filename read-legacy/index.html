<!DOCTYPE html>
<html>
  <head>
    <title>Google Docs API Quickstart</title>
    <meta charset="utf-8" />

    <style>
      pre {
        white-space: pre-wrap; /* Since CSS 2.1 */
        white-space: -moz-pre-wrap; /* Mozilla, since 1999 */
        white-space: -pre-wrap; /* Opera 4-6 */
        white-space: -o-pre-wrap; /* Opera 7 */
        word-wrap: break-word; /* Internet Explorer 5.5+ */
      }
    </style>

    <link
      rel="icon"
      type="image/png"
      href="https://cdn.glitch.global/130acd19-ddc8-473c-9ab1-09912f41140b/book-512-open.png?v=1643151318965"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="./constants.js"></script>
    <script src="./sharedFunctionality.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  </head>

  <body>
    <p>Google Docs API Quickstart</p>
    <!--Add buttons to initiate auth sequence and sign out-->
    <button id="authorize_button" style="visibility: hidden">Authorize</button>
    <button id="signout_button" style="visibility: hidden">Sign Out</button>

    <div id="controls" style="display: none;">
      Document:
      <select id="docSelector" onchange="javascript:selectDoc()"></select>
      Entry:
      <select id="entrySelector" onchange="javascript:selectEntry()"></select>
      <button onclick="selectPreviousEntry()">&lt; Previous Entry</button>
      <button onclick="selectNextEntry()">Next Entry &gt;</button>
      <input id="appendOrNot" type="checkbox" />Append to bottom?
      <input
        id="renderMarkdown"
        type="checkbox"
        onchange="javascript:renderMarkdownToggle()"
      />Render Markdown?
      <input
        id="renderImages"
        type="checkbox"
        onchange="javascript:renderImagesToggle()"
      />Render Images?
    </div>

    <div id="images" hidden="true">hi</div>
    <pre id="content"></pre>
    <div id="divContent" hidden="true"></div>

    <script type="text/javascript">
      /* exported gapiLoaded */
      /* exported gisLoaded */
      /* exported handleAuthClick */
      /* exported handleSignoutClick */

      // Discovery doc URL for APIs used by the quickstart
      const DISCOVERY_DOC = 'https://docs.googleapis.com/$discovery/rest?version=v1';

      // Authorization scopes required by the API; multiple scopes can be
      // included, separated by spaces.
      const SCOPES = 'https://www.googleapis.com/auth/documents.readonly';

      var authorizeButton = document.getElementById("authorize_button");
      var signoutButton = document.getElementById("signout_button");

      let tokenClient;
      let gapiInited = false;
      let gisInited = false;

      // Application state variables
      const divider = "\n----------------------------------------------------------------------------------------------------------------------------\n";
      var entries = {};
      var images = {};
      var currDocId = null; // Will be set from constants.js

      // Initialize document selector from constants
      function initializeDocumentSelector() {
        if (typeof LEGACY_DOCUMENT_IDS !== 'undefined') {
          LEGACY_DOCUMENT_IDS.forEach((idObject) => {
            const [docName, id] = Object.entries(idObject)[0];
            $("#docSelector").append(
              $("<option>", {
                value: id,
                text: docName,
              })
            );
          });
          
          // Select the last document by default
          var myVal = $("#docSelector option:last").val();
          $("#docSelector").val(myVal);
          currDocId = myVal;
        } else if (typeof DOCUMENT_ID !== 'undefined') {
          currDocId = DOCUMENT_ID;
        }
      }

      function selectDoc() {
        let selected = $("#docSelector").find(":selected").val();
        $("#content").html("");
        appendPre(
          "Loading " + $("#docSelector").find(":selected").text() + "....."
        );

        console.log(selected);
        currDocId = selected;

        $("#entrySelector").empty();
        entries = {};

        createDateToEntryMapping();
      }

      function selectEntry() {
        let selected = $("#entrySelector").find(":selected").val();
        console.log(selected);
        console.log($("#appendOrNot").is(":checked"));
        if (!$("#appendOrNot").is(":checked")) {
          console.log("hi");
          $("#content").html("");
          $("#divContent").html("");
          $("#images").html("");
        }

        function getASCIIArray(str) {
          const asciiArray = [];
          for (let i = 0; i < str.length; i++) {
            asciiArray.push([str.charCodeAt(i), str.charAt(i)]);
          }
          return asciiArray;
        }

        const myString = "Hello";
        const asciiCodes = getASCIIArray(entries[selected]);
        console.log(asciiCodes);

        console.log(
          entries[selected],
          entries[selected].endsWith("\n" + divider)
        );
        let lastChar = entries[selected].slice(0, -divider.length).slice(-1);
        console.log("ast char", lastChar, lastChar.charCodeAt(0));

        if (entries[selected].endsWith("\n\n" + divider) || lastChar == "\n") {
          document.getElementById("content").style.borderColor = "red";
          document.getElementById("content").style.borderWidth = "2px";
          document.getElementById("content").style.borderStyle = "solid";
        } else {
          document.getElementById("content").style.borderColor = "blue";
          document.getElementById("content").style.borderWidth = "0px";
          document.getElementById("content").style.borderStyle = "solid";
        }

        //always append both to the pre content
        appendPre(entries[selected]);
        // and to the divContent
        let old = document.getElementById("divContent").innerHTML;

        let entry = entries[selected];
        //get rid of ------- divider, it causes markdown to think it's a header
        if (entry.substring(entry.length - divider.length) == divider) {
          entry =
            entry.substring(0, entry.length - divider.length) +
            "\n\n" +
            divider;
        }
        document.getElementById("divContent").innerHTML =
          old + marked.parse(entry); //markdown rendering

        images?.[selected]?.forEach((imageURL) => {
          let img = document.createElement("img");
          img.setAttribute("src", imageURL);
          img.setAttribute("width", "200");
          document.getElementById("images").appendChild(img);
        });
      }

      function selectNextEntry() {
        $("#entrySelector > option:selected")
          .prop("selected", false)
          .next()
          .prop("selected", true);
        selectEntry();
      }

      function selectPreviousEntry() {
        $("#entrySelector > option:selected")
          .prop("selected", false)
          .prev()
          .prop("selected", true);
        selectEntry();
      }

      function renderMarkdownToggle() {
        if ($("#renderMarkdown").is(":checked")) {
          console.log("turn on");
          $("#divContent").attr("hidden", false);
          $("#content").attr("hidden", true);
          return;
        } else {
          console.log("turn off");
          $("#divContent").attr("hidden", true);
          $("#content").attr("hidden", false);
        }
      }

      function renderImagesToggle() {
        if ($("#renderImages").is(":checked")) {
          console.log("turn on images");
          $("#images").attr("hidden", false);
        } else {
          console.log("turn off images");
          $("#images").attr("hidden", true);
        }
      }

      /**
       * Callback after api.js is loaded.
       */
      function gapiLoaded() {
        gapi.load('client', initializeGapiClient);
      }

      /**
       * Callback after the API client is loaded. Loads the
       * discovery doc to initialize the API.
       */
      async function initializeGapiClient() {
        await gapi.client.init({
          apiKey: API_KEY,
          discoveryDocs: [DISCOVERY_DOC],
        });
        gapiInited = true;
        maybeEnableButtons();
      }

      /**
       * Callback after Google Identity Services are loaded.
       */
      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: '', // defined later
        });
        gisInited = true;
        maybeEnableButtons();
      }

      /**
       * Enables user interaction after all libraries are loaded.
       */
      function maybeEnableButtons() {
        if (gapiInited && gisInited) {
          document.getElementById('authorize_button').style.visibility = 'visible';
          initializeDocumentSelector();
          authorizeButton.onclick = handleAuthClick;
          signoutButton.onclick = handleSignoutClick;
        }
      }

      /**
       *  Sign in the user upon button click.
       */
      function handleAuthClick() {
        tokenClient.callback = async (resp) => {
          if (resp.error !== undefined) {
            throw (resp);
          }
          document.getElementById('signout_button').style.visibility = 'visible';
          document.getElementById('authorize_button').innerText = 'Refresh';
          document.getElementById('controls').style.display = 'block';
          await createDateToEntryMapping();
        };

        if (gapi.client.getToken() === null) {
          // Prompt the user to select a Google Account and ask for consent to share their data
          // when establishing a new session.
          tokenClient.requestAccessToken({prompt: 'consent'});
        } else {
          // Skip display of account chooser and consent dialog for an existing session.
          tokenClient.requestAccessToken({prompt: ''});
        }
      }

      /**
       *  Sign out the user upon button click.
       */
      function handleSignoutClick() {
        const token = gapi.client.getToken();
        if (token !== null) {
          google.accounts.oauth2.revoke(token.access_token);
          gapi.client.setToken('');
          document.getElementById('content').innerText = '';
          document.getElementById('divContent').innerHTML = '';
          document.getElementById('images').innerHTML = 'hi';
          document.getElementById('authorize_button').innerText = 'Authorize';
          document.getElementById('signout_button').style.visibility = 'hidden';
          document.getElementById('controls').style.display = 'none';
          $("#entrySelector").empty();
          entries = {};
          images = {};
        }
      }

      /**
       * Append a pre element to the body containing the given message
       * as its text node. Used to display the results of the API call.
       *
       * @param {string} message Text to be placed in pre element.
       */
      function appendPre(message) {
        var pre = document.getElementById("content");
        var textContent = document.createTextNode(message + "\n");
        pre.appendChild(textContent);
      }

      function setImagesIfPossible(currEntryString, currDateKey, images) {
        let imageRegex = /<([^>]*)>/;
        let imageMatch = currEntryString.match(imageRegex);
        if (imageMatch) {
          console.log(
            "hi nicooo",
            images[currDateKey],
            currDateKey,
            imageMatch[1].split(", ")
          );
          images[currDateKey] = [...imageMatch[1].split(", ")];
          console.log(images);
        }
      }

      /**
       * Fills 'entries' var
       */
      async function createDateToEntryMapping() {
        if (!currDocId) {
          appendPre("Error: No document ID specified");
          return;
        }

        try {
          const response = await gapi.client.docs.documents.get({
            documentId: currDocId,
          });
          
          var doc = response.result;
          var title = doc.title;
          appendPre('Document "' + title + '" successfully found.\n');

          let body = response.result;

          // regex only to match to < char
          // TODO: "" chars could break it
          let dateRegex =
            /(\d{4}\-(0?[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01]) \((Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day\)( \| ".*?"| <|: )|\d{4}\-(0?[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01]): )/;

          let currEntryString = "";
          let currDateKey = "";
          
          body.body.content.forEach((item) => {
            let paragraphText =
              item?.paragraph?.elements?.[0]?.textRun?.content;

            if (item?.paragraph?.elements?.length > 1) {
              console.log("multiple elements", item.paragraph.elements);
              paragraphText = item.paragraph.elements.reduce(
                (accumulator, elem) => accumulator + (elem?.textRun?.content || ""),
                ""
              );
            }

            const found = paragraphText?.match(dateRegex);

            // means it's the start of a new entry
            if (found) {
              // currDateKey is a little hacky because it assumes the header that is always present
              // i.e. first currDateKey is indeed just the empty string
              entries[currDateKey] = currEntryString;
              console.log(currDateKey, "entry saved");

              // Image stuff
              setImagesIfPossible(currEntryString, currDateKey, images);
              
              if (currDateKey) { // Don't add empty entries
                $("#entrySelector").append(
                  $("<option>", {
                    value: currDateKey,
                    text:
                      currDateKey +
                      ` (${getWordCount ? getWordCount(currEntryString) : currEntryString.split(' ').length} words)`,
                  })
                );
              }

              // Found is the regex match for the date,
              // other elements in the array are like pieces of that date
              let date =
                found[0][found[0].length - 1] == '"'
                  ? found[0]
                  : found[0].substring(0, found[0].length - 2);

              currDateKey = date;
              currEntryString = "";
            }

            currEntryString += paragraphText || "";
          });

          //straggler -
          // NOTE: duplicate dated entries won't work, and sometimes unexpected behavior (switching between entries)
          if (currDateKey && !entries[currDateKey]) {
            console.log("adding final entry");
            entries[currDateKey] = currEntryString;

            setImagesIfPossible(currEntryString, currDateKey, images);

            $("#entrySelector").append(
              $("<option>", {
                value: currDateKey,
                text: currDateKey + ` (${getWordCount ? getWordCount(currEntryString) : currEntryString.split(' ').length} words)`,
              })
            );
          }

        } catch (err) {
          appendPre("Error: " + err.message);
        }
      }

      // Keyboard navigation
      document.addEventListener("keydown", (e) => {
        if (e.code === "ArrowLeft") selectPreviousEntry();
        else if (e.code === "ArrowRight") selectNextEntry();
      });

    </script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
  </body>
</html>
